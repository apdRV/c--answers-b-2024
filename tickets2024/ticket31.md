## Билет 31. Исключения — детали

### Исключения в стандартной библиотеке 

* `std::exception`: базовый класс для всех стандартных исключений с виртуальным методом "чево" `what()`, который возвращает сишную строку (т.к. для нее, в отличие от `std::string`, не требуется динамическое выделение памяти) с описанием ошибки.

* Чаще всего удобно наследоваться не от `std::exception`, а от `std::runtime_error`/`std::logic_error`, потому что вместо переопределения `what` можно просто передать им в конструктор строчку любого типа. `logic_error` относится к ошибкам, которые можно выявить до запуска программы (ошибки разработки), а `runtime_error` — к ошибкам, которые выявляются в процессе работы программы (ошибки окружения), но в целом деление достаточно условное и строгих рамок между ними нет.

* `bad_alloc`: Специальный тип исключений, который выбрасывается, когда не получилось аллоцировать память. [cppreference](https://en.cppreference.com/w/cpp/memory/new/bad_alloc)

* `bad_cast`: Конкретный тип исключений, чтобы кидаться ими в `dynamic_cast`. При неправильном касте по указателю возвращается `nullptr`, а по ссылкам — кидается исключение `bad_cast` [Пример](https://github.com/hse-spb-2021-cpp/lectures/blob/master/15-220117/03-basic-exceptions/10-std-exceptions.cpp)

### Производительность исключений

* `happy_path`: случай, когда исключения есть, но они не бросаются. Если просто используем механизмы исключений, но не бросаем исключения, скорость работы значительно не изменится. `noexcept` тоже не оказывает влияния. На [Примере](https://github.com/hse-spb-2021-cpp/lectures/blob/master/16-220124/01-intermediate-exceptions/10-speed-no-throw.cpp) скорость работы с разными вариациями (без исключений/с/с `noexcept`) работает 328-335 ms.

* `sad_path`: регулярно кидаемся исключениями. На прошлом [Примере](https://github.com/hse-spb-2021-cpp/lectures/blob/master/16-220124/01-intermediate-exceptions/11-speed-throw.cpp) начинаем кидаться исключениями на каждой итерации и уменьшаем число итераций в 100 раз — в результате работаем 2000 ms, т.е. в 1000 раз медленнее. Причина замедления в том, что исключениям нужно уметь очень много: пролетать через единицы трансляции и через границы разделяемых библиотек, разбирать стек вызовов и уметь вызывать деструкторы нужных переменных и т.д.

* Исключения в плюсах рассчитаны на "исключительные" (ха!) ситуации, когда у нас в коде действительно что-то произошло и мы можем позволить себе замедлиться. Возвращать из функций значения с помощью исключений — плохая идея. 

### Исключения в конструкторах/деструкторах

* **Конструктор**: объект считается созданным в момент завершения конструктора. Если в процессе конструктора бросилось исключение, его деструктор вызван не будет (потому что пока конструктор работает, не очень понятно состояние объекта: какие-то инварианты могут быть установлены, а какие-то нет и непонятно, что должен делать деструктор). Ещё про исключения из конструктора см. кусочки примеров из [RAII](https://github.com/hse-spb-2021-cpp/lectures/blob/master/16-220124/01-intermediate-exceptions/05-raii.cpp) и [Примера](https://github.com/hse-spb-2021-cpp/lectures/blob/master/16-220124/01-intermediate-exceptions/06b-catch-ctor-only.cpp)

* **Деструктор**: кидаться в деструкторах исключениями опасно — если уже летит исключение и в процессе кидается ещё одно, вызывается `std::terminate`. В `c++11` все деструкторы по-умолчанию `noexcept` и в них нельзя кидать исключения вообще никогда (логично: хотим, чтобы объекты удалялись корректно, а то абоба).

* **Lifetime**: Объект считается "живым" между вызовами конструктора и деструктора. Во время их выполнения он в суперпозиции.

### Исключения при...

* **Конструировании массивов**: если в процессе конструирования `i`-го элемента массива вылетает исключение, то все элементы из префикса `[0, i-1]` корректно умирают с вызовом деструктора. В каком порядке они умирают — отдельный вопрос, не будем туда лезть. 

* **Конструировании векторов**: должно работать аналогично с массивами, но зависит от компилятора. Вообще это требование стандарта, но, например, `mingw` у Егора их не убивает (кажется, это баг в `gcc`).

* **Конструировании полей**: аналогично массивам — поля инициализируются по порядку, если какое-то поле выкинуло исключение, то уже созданные умирают строго в обратном порядке. В `member-initialization list` это тоже работает. 

* **Вызове конструктора базового класса**: если кидается сам конструктор, всё хорошо — предыдущие созданные поля умирают, никакие деструкторы (базового класса/наследника) не вызываются. Если кидается кто-то другой при уже созданном базовом классе — тоже всё хорошо, базовый класс успешно умрёт. [Пример](https://github.com/hse-spb-2021-cpp/lectures/blob/master/16-220124/02-exceptions-everywhere/06-base.cpp)

* **Вызове делигирующего конструктора**: если кидается сам делигирующий конструктор, поведение аналогично множественным примерам сверху. В общем случае, правило такое: если завершился хотя бы один конструктор, деструктор вызывать нужно, поэтому если делигирующий конструктор завершился, а затем было брошено исключение, будет вызван деструктор объекта. [Пример](https://github.com/hse-spb-2021-cpp/lectures/blob/master/16-220124/02-exceptions-everywhere/05-delegated.cpp)

* **Создании аргументов функции**: если передаём аргументы по ссылкам, то всё супер, конструкторы ссылок не кидаются. Если передаём по значению, то вызывается копирующий конструктор, который может кинуть исключение. Исключение вылетает не в теле функции, а формально как бы в строчке её вызова. Предыдущие созданные аргументы тоже корректно удаляются.

* **Возврате по значению**: в возврате по значению тоже может вылететь исключение, его можно обрабатывать, однако обычно это не делают по причине следующего пункта.
	```c++
	try {
            return a;
        } catch (...) {
            std::cout << "exception in func\n";
            return Foo();
        }
	```

* **Возврате по значению (again)**: дело в том, что бросатся может не только сама функция, но и, например, операторы, которые используют возвращаемое значение. Если там вылетит исключение, то мы потеряем возвращенное значение вне зависимости от того, обрабатывали исключения в самой функции или нет. В общем и целом: вернуть по значению так, чтобы ничего не нарушить и не потерять, может быть сложно, надо с этим аккуратно работать. [Пример целиком](https://github.com/hse-spb-2021-cpp/lectures/blob/master/16-220124/02-exceptions-everywhere/13-return-assignment.cpp)

* `stack.pop()`: почему `stack.pop()` не возвращает выкидываемое значение? Ответ — в предыдущем пункте: а что если мы сделали присваивание (в принципе, любую другую не-`noexcept` штуку)? Тогда значение из стека будет насовсем потеряно. Получается небезопасная операция без каких-либо гарантий исключений, которая в теории может просто в никуда выкинуть наш элемент. [Пример](https://github.com/hse-spb-2021-cpp/lectures/blob/master/16-220124/02-exceptions-everywhere/14-stack-pop.cpp)

