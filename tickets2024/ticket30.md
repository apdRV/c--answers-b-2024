## Билет 30. Исключения — основы

### Предусловия и постусловия конструктора/деструктора, инвариант

* Постусловие конструктора и предусловие деструктора — инвариант объекта, т.е. требуем, чтобы после конструктора и перед вызовом деструктора объект был корректным, у него соблюдались все инварианты.
* Предусловие конструктора и постусловие деструктора — объект освободил/не владеет никакими ресурсами.

### Как отличить "ошибки программирования" и "ошибки окружения" 

* Ошибки программирования: UB, нарушение инварианта, нарушения контракта
	* Ошибки программирования надо выявлять на стадии тестирования.
	* Обычно видны не сразу, а через какое-то время.
	* Можно проверять/ставить `assert`'ы/детектировать как-то иначе, но не всегда ясно, что делать после обнаружения.
	* Если случилось, то никаких гарантий нет. 
	* Например, в плюсах лучше ставить `assert`'ы по-максимуму, чтобы в случае чего программа **точно** падала.
	* Пример нарушения контракта:
```c++
void foo(const char *s) {
	printf("%s\n", s); // можно передать некорректный s — 
	// в таком случае будет ошибка именно программирования 
}
```
* Ошибки окружения — то, что можно предсказать и о чём более-менее понятно, как обрабатывать: некорректный ввод, проблемы с файлом, сетью...
	* Могут произойти независимо от программы.
	* Лучше обрабатывать и проектировать программу с их учётом.
	* В большинстве случаев понятно, что делать, если произошла некоторая ошибка. Их можно обрабатывать программными методами.
	* Например, клиент Telegram должен быстро работать, даже если сервер внезапно отвалился. 
	* Не хватило прав доступа — мб надо сообщить администратору, а не пользователю


### Обработка ошибок (болтология)

Любого рода ошибки лучше всего логировать для _разработчика_.

* В случае ошибок программирования безопаснее всего ронять процесс целиком. 
* Можно также уронить только кусочек процесса, если это не ошибка программирования. Например, если мы севрер и порвалось соединение с клиентом.
* Как-то обработать: можно попробовать другой адрес для подключения к серверу.
* Сообщить пользователю и попросить что-нибудь сделать: "файл не найден, попробуйте другой". Важно понимать, что пользователь не всегда может что-то сделать; это отдельный вопрос — о чём ему сообщать.

### Обработка ошибок без исключений

* `assert(condition)`: роняет программу, если не выполняется условие `condition`, иначе ничего не делает. Не очень хороший способ обрабатывать ошибки, т.к. **вырезается в Release-режиме**. У большиства компаний есть самописные ассёрты, которые роняют программу всегда.
* `std::exit(int)`: выходит из программы и возвращает код ошибки. Можно ручками проверять возникновение ошибки, обрабатывать её, выводить в поток `std::cerr` сообщение для пользователя и выходить через `exit`. Минусы: тяжело сделать унифицированный интерфейс для разных ситуаций, потому что всегда нужно знать полный контекст для сообщения его пользователю. 
	```c++
	std::ifstream f(filename);
    if (!f) {
        std::cerr << "Unable to open file\n";
        std::exit(1);
    }
	```
* **Коды возврата**: функции могут возвращать код ошибки, если в них что-то пошло не так (либо в качестве возвращаемого значения, либо в качестве дополнительного аргумента, но последнее странно). Например, так делает библиотека для работы с `sqlite`: каждая функция возвращает код ошибки, а реальное возвращаемое значение передаётся в качестве аргумента. Плюсы: в такой ситуации лечге вспомнить о том, что ошибку надо обработать. 
	```c++
    if (int err = sqlite3_open("does-not-exist/some-db.sqlite3", &db); err != SQLITE_OK) {  
	// Still easy to forget to check, but syntax is ugly.
        std::cout << "err = " << err << " " << sqlite3_errstr(err) << "\n";
        if (err == SQLITE_CANTOPEN) {
            std::cout << "Unable to open DB file\n";
        }
        return 1;
    }
	```

* **Состояние объекта**: Некоторые объекты поддерживают своё состояние, меняя его, если возникает какая-то ошибка. Например, `ifstream` имеет битовую маску состояния, которую можно получить через `.rdstate()` — значения соответствуют `badbit`, `failbit`, `eofbit`. Оператор конвертации к `bool` тоже проверяет какое-то подмножество этих бит. Важно, что это состояние объекта, а не результат операции. Минусы: про проверку состояния объекта легко забыть, поэтому это не очень удобный способ обрабатывать ошибки. [Пример целиком](https://github.com/hse-spb-2021-cpp/lectures/blob/master/15-220117/02-error-techniques/01-object-state-flag.cpp)
```c++
	std::ifstream f(filename);
	std::cout << "Reading from " << filename << "\n";
	// Easy to forget to check.
	std::cout << "    is_open: " << f.is_open() << "\n";
	for (;;) {
    	// https://en.cppreference.com/w/cpp/io/ios_base/iostate
    	// State, not result of operation
    	std::cout << "    status: " << f.rdstate() << "; "
              << std::ios_base::badbit << " "  // irrecoverable error
              << std::ios_base::failbit << " "  // format/extract error
              << std::ios_base::eofbit << "\n";  // EOF reached
    	if (!f) {
        	break;
    	}
    	int x = -239;
    	// Careful handling is actually required: https://en.cppreference.com/w/cpp/named_req/FormattedInputFunction
    	f >> x;
    	std::cout << "    x = " << x;
	}
```

* `errno`: макрос из Си, который хранит целочисленный код последней ошибки. Можно попробовать превратить во что-то удобоваримое через `std::strerror(errno)`. Минусы: надо проверять руками после каждой функции. 
```c++
    FILE *f = std::fopen(filename.c_str(), "r");
    std::cout << "Reading from " << filename << "\n";
    std::cout << "    f: " << f << ", errno: " << errno << " " << std::strerror(errno) << "\n";  // POSIX (not C/C++) requires that errno macro is set.
    // Problem: have to check immediately after each function. Does not propagate up.
```

### Исключения

* `throw`: кидает исключение вместо `return`. После `throw` пишется какое-то значение (специальная структурка, но вообще можно кидать любой объект, кроме `incomplete type` и ссылок на временные объекты/`incomplete type` ([источник](https://stackoverflow.com/a/17786100))). Исключение летит до ближайшего по стеку вызовов подходящего `catch`, либо роняет программу, если его не нашлось. [Пример](https://github.com/hse-spb-2021-cpp/lectures/blob/master/15-220117/03-basic-exceptions/01-basic.cpp) 
	```c++

	struct unable_to_read {};

	int read() {
		int n;
		if (!(std::cin >> n)) {
			throw unable_to_read();
		}
		return n;
	}
	```
* `try/catch`: пытаемся выполнить блок кода в `try`, если вылетело исключение, пытаемся поймать его в `catch` и, если тип совпадает (разрешены base-casts, но аккуратно со слайсингом; неявного приведения типов нет), выполнить блок в `catch`. [Про наследование](https://github.com/hse-spb-2021-cpp/lectures/blob/master/15-220117/03-basic-exceptions/03-catch-inheritance.cpp)
	```c++
	try {
        read();  // if exception is thrown, it's propagated
    } catch (const unable_to_read &err) {  // looking for the first catch
        std::cout << "Unable to read number\n";
    }
	```
* **Много** `catch`: можно сделать сколько угодно `catch` для разных типов ошибок.
```c++
struct err1 {};
struct err2 {};

int main() {
	try {
       	// throw err1();
       	// throw err2();
  		std::vector<int> vec(-1);
	} catch (const err1 &) {
   		std::cout << "1\n";
	} catch (const err2 &) {
   		std::cout << "2\n";
	} catch (...) {  // Exceptions only. Not UB, not assertions!
   		std::cout << "3\n";
   		// throw;  // rethrow current exception
	}  // no 'finally' block!
}
```
* Вложенные `try/catch`: правило простое — сначала идём в `catch` ближайшего к нам `try` блока (**того, в котором мы находимся**), ищем подходящий `catch`, если не нашли — "вылетаем нафиг из функции". [Пример](https://github.com/hse-spb-2021-cpp/lectures/blob/master/15-220117/03-basic-exceptions/04-complex-try-block.cpp)

* **Слайсинг**: исключения можно перебрасывать пустым `throw;` — тогда кидается текущее обрабатываемое исключение его родного типа. Если мы сначала поймали исключение `catch (const Base &a)`, а потом сделали `throw a;`, то выбросится исключение именно типа `Base`, даже если `a` было `Derived`. 
	```c++
	try {
        throw std::runtime_error("Hello World");
    } catch (std::exception &a) {
        // throw a;  // oops, slicing
        throw;  // no slicing
    }
	```

* **Уничтожение локальных ресурсов:** Когда функция аварийно завершается, выбросив исключение, в ней вызываются деструкторы всех локальных переменных с automatic storage duration в корректном порядке, это и называется раскруткой стека. Другой вопрос — что происходит, когда исключение вылетает из деструктора. :)

* Сказанное выше работает только в случае, если исключение было поймано. В противном случае, то, что происходит между последним `catch` и завершением программы — `implementation-defined`. [Пример, в котором можно закомментить `try/catch` в `main`](https://github.com/hse-spb-2021-cpp/lectures/blob/master/15-220117/03-basic-exceptions/01b-destructors.cpp)

* `RAII`: состоит из двух частей — про конструктор и про деструктор. Обычно, когда говорят про `RAII`, имеют в виду только вторую часть про деструктор. [Пример целиком](https://github.com/hse-spb-2021-cpp/lectures/blob/master/16-220124/01-intermediate-exceptions/05-raii.cpp)
	1. Конструктор завершается тогда и только тогда, когда ему удалось инициализировать все инварианты и захватить все ресурсы, в противном случае должны кинуть исключение.
	2. Деструктор корректно освобождает все используемые ресурсы.
```c++
    // RAII: Resource Acquisition Is Initialization
    {
        std::vector<int> v(1'000'000);
        // Invariant: v.size() == 1'000'000, memory allocation succeeded.
        v[999'999] = 123;
        // RAII part 1: constructor has to establish invariant and grab resources. Throw an exception if that's impossible. No exit codes.
    }  // RAII part 2: destructor has to free all resource.
```
