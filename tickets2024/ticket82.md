## Билет 82. Вспомогательные инструменты метапрограммирования

#### 'std::apply' для вызова функции с параметрами из кортежа

'std::apply' позволяет вызывать функцию, аргументами функции станут элементы кортежа, переданного в 'std::apply'.
Никакой динамической типизации нет, типы известны на этапе компиляции.
```c++
void foo(int a, string b) {
    assert(a == 10);
    assert(b == "hello");
}

int main() {
    auto t = std::make_tuple(10, "hello");
    std::apply(foo, t);  // You can call a function
}
```

#### Ссылки внутри 'std::tuple', функция 'std::tie'

#### Необходимость правильной расстановки 'noexcept' для эффективной работы. Пример: копирование 'std::vector<T>' может использовать разные алгоритмы.

#### Условный оператор 'noexcept', конструкция 'noexcept(noexcept(expr))'

#### 'std::declval', где можно вызывать, зачем













