## Билет 55. Особенности и идиомы Си

Код с лекций: [`25-220418`](https://github.com/hse-spb-2021-cpp/lectures/tree/master/25-220418), [`26-220425`](https://github.com/hse-spb-2021-cpp/lectures/tree/master/26-220425) 

### `printf`/`scanf`

* **Ограничение буфера для `%s`**: можно указать предельное число символов, которые можно считать в определенный буфер (для `scanf`), или количество символов, которые должна занимать строчка (для `printf`, если строчка короче, она добивается пробелами до нужной длины). В примере ниже говорим `scanf` считать не более 9 любых символов, кроме `-` в `buf1`, а потом строчку длины не более 19 в `buf2`.
	```c++
	char buf1[10], buf2[20];
    	int x;
    	int read1 = scanf(" %9[^-]-%19s%*d%d", buf1, buf2, &x);
	```

* Аналогичный пример для `printf` — здесь значение между `%` и выводящимся типом указывает на желаемую длину итоговой строки. Если наша строка меньше, она дополнется слева нулями.
	```c++
		// buf1 = "short"
		// buf2 = "longer buffer"
	    printf("     01234567890123456789\nbuf1=%9s\nbuf2=%19s\n", buf1, buf2);
		// output: "     01234567890123456789"
		//         "buf1=    short"
		//         "buf2=      longer buffer"
	```

* `%n`: записывает в аргумент число прочитанных символов. С его помощью можем отслеживать, на какой позиции мы находимся, и таким образом (и с использованием `sscanf`, см. ниже), например, эмулировать `stringstream` (то есть каждый последующий раз чиать с позиции, на которой остановились).
	```c++
	char buf[] = " 123+   45"
	int x, read;
        int res = sscanf(buf + pos, "%d%n", &x, &read);
	// read is 4: [space]123
	```

* `O(n^2)`: `sscanf` — вместо `stdin` читает данные из буфера и может работать за линейное время от его размера. Стандарт не гарантирует производительность `sscanf` и большинство его реализаций под капотом вызывают линейный `strlen`, поэтому если читать из буфера маленькими кусочками, можно наткнуться на квадратичную асимптотику (здесь место для шутки про GTA Online и `O(10MB ^ 2)`, повеселите своего проверяющего)


### Designated initializer

* Позволяет явно указать, какие поля структуры/элементы массива инициализировать. Все неуказанные поля зануляются через `zero initialization`. Аргументы можно указывать в любом порядке, можно мешать `designated` синтаксис с обычным и т.д. В стандарте появились только в С++20, однако `gcc` и `clang` могут их поддерживать и в более ранних версиях.
	```c++
	int a[6] = { [1] = v1, v2, [4] = v4 }; // [0, v1, v2, 0, v4, 0]
	// ...
	struct point {
    		int x, y, z;
	};
	// ...
	struct point p = {.z = 10, .y = 20};
	```

### Макросы для констант и inline-функций

* `const`: в C есть константность, но константы занимают место в памяти, имеют адрес и в целом работают слегка медленнее, чем хотелось бы, поэтому в качестве констант предпочитают использовать макросы типа `#define N 100`. Да, это не типобезопасно, да, могут быть проблемы с круглыми скобочками, но исторически сложилось так. Для корректного типа можно делать си-стайл касты (`#define N (int)100`), но это уже опционально и не так популярно.

* `inline`: аналогично с `inline`-функциями: они появились только в `C99`, не все компиляторы сразу научились их поддерживать, сами функции плохо оптимизируются компилятором. По этой причине `inline`-функции заменяют функции через макросы. Важно помнить, что это всё ещё не очень хорошая штука: надо аккуратно работать с круглыми скобочками, макросы не очень читаемы, компиляторы их плохо проверяют, зато они лучше оптимизируются и не требуют поддержки каких-то сложных механизмов, типа шаблонов. 
```c++
#define max(a, b) ((a) < (b) ? (b) : (a))
// Inline functions are since C99 only, not everyone supports them.

#define json_object_object_foreach(obj, key, val)                          \
    char *key = NULL;                                                      \
    struct json_object *val = NULL;                                        \
    struct lh_entry *entry##key;                                           \
    struct lh_entry *entry_next##key = NULL;                               \
    for (entry##key = json_object_get_object(obj)->head;                   \
         (entry##key ? (key = (char *)lh_entry_k(entry##key),              \
                       val = (struct json_object *)lh_entry_v(entry##key), \
                       entry_next##key = entry##key->next, entry##key)     \
               	     : 0);                                                 \
        	 entry##key = entry_next##key)
	// `json_object_object_foreach` is harder to optimize because it would need
	// pointer-to-function optimization.
```

### `goto`

* `goto label`: операция, которая переходит к определенной метке `label` в коде. Синтаксически, С/C++ позволяют перед любым statement написать метку (`label:`) и к ней перепрыгивать. Эта штука очень древняя и активно использовалась ещё тогда, когда компьютеры не умели ни в какие сложные конструкции типа ветвления с фигурными скобками. Циклы тогда писались примерно так: (пожалуйста, не повторяйте этого дома)
```c++
label:
    printf("%d\n", i);
    i++;
    int x = 5;
    printf("  x=%d\n", x);
    x++;
    if (i < n)
        goto label;
```

* Важное замечание: `label`'ы можно писать только перед statement, то есть, например, не получится сделать прыжок в конец фигурных скобок. Зато есть пустые statement'ы `;`, перед которыми `label` писать можно.
```c++
{
aboba: // bad
aboba:; // ok, ; is an empty statement
}
```
* Goto Statement Considered Harmful: строить свой код только на `goto` — не очень хорошая идея, потому что она побуждает к переиспользованию кода без сохранения внятного потока программы. Вы будете постоянно прыгать туда-сюда и в итоге запутаетесь сами или запутаете человека, которому придётся это читать. [Дейкстра](http://hosting.vspu.ac.ru/~chul/dijkstra/goto/goto.htm)

* `goto fwd`: прыгать вперёд тоже можно, но нужно быть аккуратными с перепрыгиванием переменных. В С перепрыгивать можно, тогда переменная инициализируется нулём, в C++ запрещено.
```c++
int n = 10;
    if (n >= 5)
        goto big_n;
    int c = 100;  // Ok in C, "crosses initialization" in C++.
    printf("n is small\n");
    n += 100;
big_n:
    printf("n is big: %d; c=%d\n", n, c);
```

* **`goto` для выхода из циклов**: бывает очень неудобно выходить из вложенных циклов с помощью `break`, потому что это вызывает нагромождение абсолютно ненужного кода. Вместо этого можно использовать `goto` к лейблу за пределы циклов — в таком случае все переменные внутри циклов корректно умрут и будут вызваны их деструкторы. Альтернатива такому `goto` — лямбда, которая делает в нужном месте `return`.
```c++
for (int i = 0; i < 10; i++)
        for (int j = 0; j < 10; j++) {
            if (i * j == 24) {
                std::printf("%d %d\n", i, j);
                goto after_loop;
            }
        }
    after_loop:;

    auto [a, b] = []() {
        for (int i = 0; i < 10; i++)
            for (int j = 0; j < 10; j++) {
                if (i * j == 24) {
                    return std::make_pair(i, j);
                }
            }
    }();
    std::printf("%d %d\n", a, b);
```

* **`goto` для обработки ошибок**: ситуация: есть код, который открывает файл, считывает оттуда число, выделяет буфер, затем считывает ещё сколько-то чисел. На каждом из этих этапов может произойти ошибка: файл не открылся, число не считалось, буфер не выделился — при этом мы всегда должны освободить определенную часть ресурсов — например, файл надо закрыть почти всегда, а вот буфер очищать только если он предварительно выделился. Можно, конечно, в каждом месте руками вставить обработку ошибок, освобождение ресурсов и `return`, но тогда получится очень много дублирования кода. Вместо этого используется такая концепция: точка выхода из функции только одна, перед ней освобождаются все необходимые ресурсы и вызываются деструкторы, а в случае возникновения ошибки программа прыгает в какой-то суффикс этого процесса.

```c++
FILE *f = fopen(argv[1], "r");
if (!f) {
    printf("Unable to open file\n");
    goto f_closed;
}

int n;
if (fscanf(f, "%d", &n) != 1) {
    printf("Unable to read n\n");
    goto f_opened;
}
int *arr = malloc(n * sizeof(int));
if (!arr) {
    printf("Unable to allocate array for %d ints\n", n);
    goto buf_freed;
}

for (int i = 0; i < n; i++) {
    if (fscanf(f, "%d", &arr[i]) != 1) {
        printf("Unable to read element %d\n", i + 1);
        goto err;
    }
}

// ...

err:
    free(arr);
buf_freed:
f_opened:
    fclose(f);
f_closed:
    return ret;
```

### Union, anonymous union, anonymous struct

* **`Union`**: специальный тип, который хранит некоторые объекты в одном месте в памяти и позволяет обращаться только к одному своему полю единовременно. Например, в программе может произойти нажатие на кнопку клаваиатуры или движение мышки. С помощью `Union` можем создать общую структуру, которая позволит хранить в себе любое из этих событий и типобезопасно к ним обращаться + получаем экономию в памяти. [Пример целиком](https://github.com/hse-spb-2021-cpp/lectures/blob/master/26-220425/02-unions/01-union.c)
```c++
enum EventType { MOUSE, KEYBOARD };

struct MouseEvent {  // ~12 bytes
    int x;
    int y;
    int button;
};

struct KeyboardEvent {  // ~8 bytes
    int key;
    int is_down;
};

union AnyEvent {  // ~12 bytes, ensures proper alignment for all.
    struct MouseEvent mouse;
    struct KeyboardEvent keyboard;
};

struct Event {  // 16
    int type;
    union AnyEvent event;
};
```

* Что происходит, если мы обращаемся не к тому полю, которые записали? В С++ конкретное поле в момент записи в него активизируется, остальные деактивируются. Обращение к деактивированному полю — UB. В С никакой активизации нет, а при обращении к другому члену `Union` происходит `reinterpret_cast`, который не нарушает Strict Aliasing Rule. Так, например, через юнионы можно преобразовывать `int` во `float`, когда через указатели или c-style-cast нельзя.

* При записи в другое поле `Union` активность меняется, старые данные становятся недоступны и могут затерется.

* `Union` и `Struct` можно объявлять вложенно, это просто другой способ записи вложенных конструкций без указания типа, доступный и в С, и в С++.
```c++
struct Event {  // 16
    int type;
    union {
        struct {
            int x;
            int y;
            int button;
        } mouse;
        struct {
            int key;
            int is_down;
        } keyboard;
    } event;
};
```
* **`Anonymous union`**: в предыдущем примере уберём имя `event` у `union`, получим безымянный `union`. Теперь у `Event` есть два поля: одно `type`, второе без имени. На практике это означает, что теперь нам не нужно писать имя структуры при обращении к его полям: `ev.event.mouse.x --> ev.mouse.x`. Поддерживается C++98+ и C11+. [Пример](https://github.com/hse-spb-2021-cpp/lectures/blob/master/26-220425/02-unions/02-anonymous-union.c)

* **`Anonymous struct`**: аналогично — можем опустить тип структуры и имя поля, тогда получим возможность напрямую обращаться к её полям без набора дополнительных символов. Если структура вложена в какую-то другую, смысла в анонимности нет — можно было бы с тем же успехом сделать её поля полями родителя, а вот в `union` это удобно. Так как `uinon`'ы не очень популярны в С++, анонимные структуры там до сих пор не стандартизированны, зато в стандарте C11+. [Пример целиком](https://github.com/hse-spb-2021-cpp/lectures/blob/master/26-220425/02-unions/03-anonymous-struct.cpp)
```c++
union Foo {
    struct X {  // OK
        int x1, x2;
    };

    struct Y {  // OK
        int y1, y2;
    } y;

    struct {  // OK
        int z1, z2;
    } z;

    struct { // OK, anonymous
        int wtf1, wtf2;
    };
};

// ...
Foo f;
f.z.z1 = 10;
f.wtf1 = 20;
```

